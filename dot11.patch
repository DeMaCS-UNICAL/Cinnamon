--- dot11.py	2010-09-11 15:04:02.000000000 +0200
+++ ./scapy/layers/dot11.py	2012-03-04 18:15:58.000000000 +0100
@@ -150,8 +150,45 @@
         else:
             return s,None
 
+#WARNING!: Added class for supporting drivers that deliver FCS frame field
+class FCSField(StrFixedLenField):
+    def __init__(self ,name, default):
+        StrFixedLenField.__init__(self, name, default, 4)
+
+    def is_applicable(self, pkt):
+        return pkt.has_FCS()
+
+    def getfield(self, pkt, s):
+        if self.is_applicable(pkt):
+            l = self.length_from(pkt)
+            return s[:-l], self.m2i(pkt, s[-l:])
+        else:
+            return s,None
+
+    #However drivers shouldn't receive a FCS field, because
+    #it is generated by the driver or the firmware.
+    def addfield(self, pkt, s, val):
+        return s
+    
+    def i2repr(self, pkt, x):
+        if x is None:
+            return "None"
+        else:
+            s="0x"
+            for char in x:
+                s+="%02x"%(ord(char),)
+                
+            return s
+#--
+
+
 class Dot11(Packet):
     name = "802.11"
+    #WARNING!: Added class attribute
+    #We avoid to waste time parsing the FCS field when...
+    #we know that the driver skips it
+    fcs_enabled=False
+    #--
     fields_desc = [
                     BitField("subtype", 0, 4),
                     BitEnumField("type", 0, 2, ["Management", "Control", "Data", "Reserved"]),
@@ -162,8 +199,31 @@
                     Dot11Addr2MACField("addr2", ETHER_ANY),
                     Dot11Addr3MACField("addr3", ETHER_ANY),
                     Dot11SCField("SC", 0),
-                    Dot11Addr4MACField("addr4", ETHER_ANY) 
+                    Dot11Addr4MACField("addr4", ETHER_ANY), 
+                    #WARNING!: Added a new field.
+                    FCSField("FCS", None)
+                    #--
                     ]
+    
+    #WARNING!: Added new methods for enabling/disabling the FCS field processing,...
+    #parsing the FCS field, and checking whether a frame has such field.
+    @classmethod
+    def enable_FCS(cls, fcsupport):
+        cls.fcs_enabled=fcsupport
+        
+    def pre_dissect(self, s):
+        if self.fcs_enabled:
+            chksum=crc32(s[:-4])
+            self.fcs=(s[-4:]==struct.pack("<i",chksum))
+        else:
+            self.fcs=False
+    
+        return s
+
+    def has_FCS(self):
+        return self.fcs
+    #-
+    
     def mysummary(self):
         return self.sprintf("802.11 %Dot11.type% %Dot11.subtype% %Dot11.addr2% > %Dot11.addr1%")
     def guess_payload_class(self, payload):
